I"c<h2 id="introduction">Introduction</h2>
<p>The book <em>The Elements of Computing Systems</em> by Noam Nisan and Shimon Schocken explains the design of a modern computer starting at the level of the most basic logic gates and working up to high level programming languages and operating systems.</p>

<p>Each chapter of the book contains a project to be completed, such as designing a CPU, building an assembler and implementing an operating system. Each chapters and project builds on the knowledge and work in the previous chapters (though they could also be completed out of order as independent exercises).</p>

<p>You can find more information about the book here: <a href="https://www.nand2tetris.org">From Nand to Tetris</a>.</p>

<p>These are my notes as I work through the book. I’m sure there are much better solutions than mine to many of the problems.</p>

<h2 id="chapter-1-boolean-logic">Chapter 1: Boolean Logic</h2>

<p>The project for this chapter is to implement a series of logic gates using only NAND gates as a primitive building block (plus any other gates once you have implemented them). For this chapter, I’ve shown them all using the NAND gates.</p>

<p>I simulated these using a tool called <a href="http://www.cburch.com/logisim/">Logisim</a>, which is a lot of fun to tinker with. The circuit images for the gates are screenshots from Logisim.</p>

<h3 id="nand-1-bit">NAND (1-bit)</h3>

<table>
  <tbody>
    <tr>
      <td>Inputs</td>
      <td>a, b</td>
    </tr>
    <tr>
      <td>Outputs</td>
      <td>out</td>
    </tr>
    <tr>
      <td>Function</td>
      <td>If a = b = 1 then out = 0, else out = 1</td>
    </tr>
  </tbody>
</table>

<p>This logic gate outputs a true value (1) except when both inputs are true. Don’t need to implement this one - it’s the building block for all the rest.</p>

<p><img src="/assets/images/programming/elements/1-nand.png" alt="Circuit diagram of a NAND gate" /></p>

<h3 id="not-1-bit">NOT (1-bit)</h3>

<table>
  <tbody>
    <tr>
      <td>Inputs</td>
      <td>in</td>
    </tr>
    <tr>
      <td>Outputs</td>
      <td>out</td>
    </tr>
    <tr>
      <td>Function</td>
      <td>If in = 0 then out = 1, else out = 0</td>
    </tr>
  </tbody>
</table>

<p><img src="/assets/images/programming/elements/1-not.png" alt="Circuit diagram of a NOT gate made from a NAND gate" /></p>

<h3 id="and-1-bit">AND (1-bit)</h3>

<table>
  <tbody>
    <tr>
      <td>Inputs</td>
      <td>a, b</td>
    </tr>
    <tr>
      <td>Outputs</td>
      <td>out</td>
    </tr>
    <tr>
      <td>Function</td>
      <td>If a = b = 1 then out = 1, else out = 0</td>
    </tr>
  </tbody>
</table>

<p>NAND is really NOT+AND, so another NAND gate will turn NAND back into AND.</p>

<p><img src="/assets/images/programming/elements/1-and.png" alt="Circuit diagram of an AND gate made from two NAND gates" /></p>

<h3 id="or-1-bit">OR (1-bit)</h3>

<table>
  <tbody>
    <tr>
      <td>Inputs</td>
      <td>a, b</td>
    </tr>
    <tr>
      <td>Outputs</td>
      <td>out</td>
    </tr>
    <tr>
      <td>Function</td>
      <td>If a = b = 0 then out = 0, else out = 1</td>
    </tr>
  </tbody>
</table>

<p>Negating the two inputs before they pass through a NAND gate makes an OR gate.</p>

<p><img src="/assets/images/programming/elements/1-or.png" alt="Circuit diagram of an OR gate made from three NAND gates" /></p>

<h3 id="xor-1-bit">XOR (1-bit)</h3>

<table>
  <tbody>
    <tr>
      <td>Inputs</td>
      <td>a, b</td>
    </tr>
    <tr>
      <td>Outputs</td>
      <td>out</td>
    </tr>
    <tr>
      <td>Function</td>
      <td>If a ≠ b then out = 1, else out = 0</td>
    </tr>
  </tbody>
</table>

<p>XOR only outputs true when one of the inputs is true, not both. This was the first tricky one for me.
I’ve marked in the gate functions being performed by clusters of NANDs.</p>

<p><img src="/assets/images/programming/elements/1-xor.png" alt="Circuit diagram of an XOR gate made from five NAND gates" /></p>

<h3 id="mux-1-bit">MUX (1-bit)</h3>

<p>Multiplexer, can control which input passes through to the output by using a <em>select</em> input.</p>

<table>
  <tbody>
    <tr>
      <td>Inputs</td>
      <td>a, b, sel</td>
    </tr>
    <tr>
      <td>Outputs</td>
      <td>out</td>
    </tr>
    <tr>
      <td>Function</td>
      <td>If sel = 0 then out = a, else out = b</td>
    </tr>
  </tbody>
</table>

<p><img src="/assets/images/programming/elements/1-mux.png" alt="Circuit diagram of a MUX gate made from eight NAND gates" /></p>

<h3 id="dmux-1-bit">DMUX (1-bit)</h3>

<p>Demultiplexer, controls which output the input passes through to.</p>

<table>
  <tbody>
    <tr>
      <td>Inputs</td>
      <td>in, sel</td>
    </tr>
    <tr>
      <td>Outputs</td>
      <td>a, b</td>
    </tr>
    <tr>
      <td>Function</td>
      <td>If sel = 0 then { a = in, b = 0 } else { a = 0, b = in }</td>
    </tr>
  </tbody>
</table>

<p><img src="/assets/images/programming/elements/1-dmux.png" alt="Circuit diagram of a DMUX gate made from five NAND gates" /></p>

<h3 id="multi-bit-gates">Multi-bit gates</h3>

<p>These are simply arrays of the above gates, e.g. an 8-bit OR gate applies an OR function to 8 separate pairs of input bits (a[0 to 7] and b[0 to 7]).</p>

<h3 id="multi-way-gates">Multi-way gates</h3>

<p>For multi-way gates, the logic applies to all of the inputs at once, not separately. For example, a multi-way OR gate with 8 input bits would have a single output bit that would be true if any of the 8 input bits were true.</p>

<h3 id="multi-way-or-8-way">Multi-way OR (8-way)</h3>

<table>
  <tbody>
    <tr>
      <td>Inputs</td>
      <td>in[8]</td>
    </tr>
    <tr>
      <td>Outputs</td>
      <td>out</td>
    </tr>
    <tr>
      <td>Function</td>
      <td>out = Or(in[0], in[1], in[2], …, in[7])</td>
    </tr>
  </tbody>
</table>

<p>Is there a version that uses less gates?</p>

<p><img src="/assets/images/programming/elements/1-8-way-or.png" alt="Circuit diagram of an 8-way OR gate made from 20 NAND gates" /></p>

<h3 id="4-way-16-bit-mux">4-way 16-bit MUX</h3>

<h3 id="8-way-16-bit-mux">8-way 16-bit MUX</h3>

<h3 id="4-way-1-bit-dmux">4-way 1-bit DMUX</h3>

<h3 id="8-way-1-bit-dmux">8-way 1-bit DMUX</h3>
:ET